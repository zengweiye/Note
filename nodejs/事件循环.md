## 事件循环

### 图解

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

### timers

执行被`setTimeout`和`setInterval`的调度回调函数

计时器指定可以执行回调的阈值，而不是用户希望执行的事件。操作系统的调度或其他正在运行的回调可能会延迟它们。



### pending callbacks

执行延迟到下个循环迭代的`I/O`回调



### idle,prepare

仅系统内部调用



### poll

检索新的`I/O`事件，执行与`I/O`相关的回调

两大功能：

1. 计算应该阻塞和轮询`I/O`的时间
2. 处理轮询队列的事件

两种情况：

1. 如果轮询不是空，事件循环将循环访问回调队列并同步执行他们，直到队列已用尽，或者达到了系统的硬件限制
2. 如果为空：
   1. 如果被`setImmediate`调度，结束轮询并继续检查阶段
   2.  未被 `setImmediate()`调度，则事件循环将等待回调被添加到队列中，然后立即执行。



### check

`setImmediate()` 回调函数在这里执行



### **close callbacks**

如果套接字或处理函数突然关闭（例如 `socket.destroy()`），则`'close'` 事件将在这个阶段发出。否则它将通过 `process.nextTick()` 发出。



### `setTimeout(0)`与`setImmediate()`

其实`setTimeout(0)`为`setTimeout(1)`，因为`setTimeout`函数中0并不是合法值，会转化成1。

而他们的先后问题其实和硬件有关，如果在进行事件循环的`timers`时，已经过了1 ms，那么先执行`setTimeout`，否则执行`setImmediate`。



### `process.nextTick`

`process.nextTick`能在事件循环中的任意阶段进行，具有高优先度，执行完`nextTick`才会继续进行事件循环。