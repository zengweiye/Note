## `V8`垃圾回收机制

### 内存限制

在32位机器中，内存为`0.7G`

在64为机器中，内存为`1.4G`

Node在启动 时可以传递`--max-old-space-size`或`--max-new-space-size`来调整内存限制的大小



### 为什么会有内存限制

`V8`做一次小的垃圾回收需要50毫秒以上，一次非增量式的垃圾回收甚至要1秒以上，而垃圾回收将会引起`js`引擎暂停，这样会导致性能和响应能力的下降。



### 垃圾回收算法

内存分为新生代和老生代，新生代使用`scavenge`算法，老生代使用`Mark-Sweep`和`Mark-Compact`

#### `Scavenge`算法

`Scavenge`算法主要采用了`Cheney`算法，通过复制的方式来进行垃圾回收

它将堆内存一分为二，分成两个`semispace`空间，只有一个处于使用状态，称为`from`空间，另一个处于闲置状态，称为`to`空间。

当进行垃圾回收时，会检查`from`空间的存活对象，如果存活，将存活对象复制到`to`对象中，否则进行释放，结束后将`to`空间和`from`空间进行对换。

**新生代晋升**

1. 已经经历过一次`Scavenge`回收

   在进行回收时，会检查对象的内存地址来判断是否经历过`Scavenge`回收，如果已经经历过，则将从新生代的`from`空间复制到老生代

2. 空间占比超出限制

   如果在从`from`空间复制到`to`空间时，检测到对象超出`to`空间占比的25%，则直接晋升到老生代空间。



#### `Mark-Sweep`和`Mark-Compact`

**Mark-Sweep**分为两个阶段，标记和清除

在标记阶段遍历堆中所有对象，并标记活着的对象，在清除阶段只清除没有标记的对象。

**Mark-Compact**负责处理对象被清除后留下的内存空间不连续问题。

它将所有存活的对象往一段进行移动，移动完毕后，直接清除边界外的内存，得到一整块空闲的内存地址。



#### `Incremental Marking`

为了避免`v8`在进行垃圾回收时停顿时间过大，采用`Incremental Marking`增量标记进行，将垃圾回收和应用逻辑交替进行，减少最大停顿时间。

同时也在后续引入了`lazy sweeping`延迟清理和`incremental compaction`增量式清理，让清理和整理动作变成增量式的。