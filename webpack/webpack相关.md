## `webpack`相关

### `webpack`模块打包原理

`webpack`实际上为每个模块创造了一个可以导入和导出的环境，本质上没有修改代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致



### `webpack`功能和原理

1. 代码转换：`ts`转成`js`，`scss`转成`css`等
2. 文件优化：压缩`js`, `css`, `html`等代码，压缩图片
3. 代码分割：提取多个页面的公共代码，提取首屏不需要执行的代码让其异步加载
4. 模块合并：将各个模块分类合并成一个文件
5. 自动刷新：监听代码的变化，自动构建，刷新浏览器
6. 代码校验：检测代码是否符合标准，以及单元测试是否通过
7. 自动发布：更新代码后，自动构建线上发布代码并传输到线上。



### `webpack`构建过程

`初始化参数`：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数

`开始编译`：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译

`确定入口`：根据配置中的 entry 找出所有的入口文件

`编译模块`：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理

`完成模块编译`：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系

`输出资源`：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会

`输出完成`：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统



### `webpack`与`gulp`，`grunt`区别

`gulp`只是一个`task runner`，无法做到模块化

`webpack`是一个模块化打包工具，能递归打包文件中所有模块，最终生成打包后的文件。



### `entry`与`output`

`entry`：构建项目的起点

`output`：输出打包好的代码的位置以及命名



### `loader`与`plugins`

`loader`：用于转换某一类型的文件，并且引入到打包出的文件中。本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 `webpack` 只认识 `JavaScript`，所以 `Loader `就成了翻译官，对其他类型的资源进行转译的预处理工作。

`plugins`：能用于打包优化，资源管理和注入环境变量。在 `webpack` 运行的生命周期中会广播出许多事件，`plugin` 可以监听这些事件，在合适的时机通过 `Webpack` 提供的 `API` 改变输出结果



### `bundle`,`chunk`,`moudle`

`bundle`：打包出来的文件

`chunk`：进行模块的依赖分析时代码分割出来的代码块

`moudle`：开发中的单个模块



### 模块热更新

不用刷新浏览器就自动更新

可以通过`HotMouleReplacementPlugin()`进行开启

`WDS`与浏览器之间维护了一个`websocket`，当本地资源发生改变时，`wds`会向浏览器推送更新，并带上构建时的`hash`，与上一次资源进行对比。对比出差异时通过发起`ajax`请求进行获取更改内容，这样客户端就能这些信息继续向`wds`发起`jsonp`请求获取该`chunk`的增量更新。

后续由`HotModulePlugin`进行处理。



### 文件监听原理

通过轮询判断文件的最后编辑时间是否变化，如果某个文件发生变化，不会立即告诉监听者，而是缓存起来，等`aggregatetime`后执行。



### `fileName`与`chunkFileName`

`fileName`是指列在`entry`中，打包后输出文件的名称

`chunkFileName`是指未列在`entry`中，却又需要被打包出来的文件的名称



### `hash`、`chunkHash`与`contentHash`

`hash` 计算与整个项目的构建相关；

`chunkhash` 计算与同一 `chunk` 内容相关；

`contenthash` 计算与文件内容本身相关。