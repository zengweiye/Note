

## HTTP

### 从输入网址到页面生成的步骤

1. 浏览器解析出主机名
2. `DNS`进行域名解析，转化为`IP`地址
3. 浏览器获取端口号
4. 根据`IP`地址和端口号进行`TCP/IP`连接
   1. 进行三次握手
      1. 客户端向服务器发送`SYN`报文请求连接，变为`SYN_SEND`状态
      2. 服务器接收到`SYN`报文并确认后，向客户端发送`ACK`报文，变为`SYN_RECV`状态
      3. 客户端接收到服务端的`SYN`和`ACK`报文后，发送`ACK`包进行确认，然后两者都变成`ESTABLISHED`状态
   2. 四次挥手
      1. 客户端向服务器发送`FIN`报文请求关闭连接，转为`FIN_WAIT_1`状态
      2. 服务器接收到`FIN`报文后，向客户端发送`ACK`报文，进入`CLOCK_WAIT`状态，客户端接收到报文后，进入`FIN_WAIT_2`状态
      3. 服务器在发送完剩余所有数据后，向客户端发送`FIN`报文请求关闭连接，进入`LAST_ACK`状态
      4. 客户端接受到服务器的`FIN`报文后，发送`ACK`报文，并转为`TIME_WAIT`状态，服务器接受到`ACK`报文后，关闭连接，变为`CLOSED`状态
5. 浏览器发送`HTTP`请求
   1. 浏览器向服务器发送请求命令
   2. 发送请求头信息，如果`POST`提交，则继续发送请求体
6. 服务器响应请求
   1. 服务器应答
   2. 向浏览器发送头信息
   3. 继续向浏览器发送数据
7. 浏览器读取服务器返回的响应报文
8. 断开`TCP`连接。
9. 浏览器根据报文进行对`HTML`进行渲染



### 浏览器的渲染过程

1. 解析`HTML`生成`DOM`树
   1. 浏览器接收到服务器的文档后，会遍历文档节点，生成`DOM`树。DOM树生成过程中可能会被`CSS`和`JS`的加载阻塞。
2. 解析`CSS`生成`CSSOM`树
   1. 浏览器解析`CSS`文件并生成`CSS`规则树，每个`CSS`文件都会被分析成一个`StyleSheet`对象，每个对象都包含`CSS`规则
3. 将`DOM`树和`CSSOM`树合并在一起生成渲染树
   1. 浏览器从`DOM`的根节点开始遍历，并找到其相应的`CSS`规则进行应用，构成渲染树
4. 遍历渲染树，开始布局，计算每个节点的位置大小信息
   1. 从渲染树的根节点开始遍历，确定每个节点对象在页面上的确切大小和位置
5. 将渲染树每个节点绘制在屏幕
   1. 在绘制阶段，遍历渲染树，调用渲染器的`paint`方法进行在屏幕上显示。



### `repaint`和`reflow`

`repaint`：屏幕的一部分重画，不影响整体布局，即不需要重新计算。

`reflow`：元件的几何尺寸改变，需要重新验证并计算渲染树。

`display:none`会触发`reflow`，因为元件不存在与渲染树了，而`visiable:hidden`不需要，因为只是隐藏起来，仍然占据空间。



### 缓存

#### 基本原理

- 1）浏览器在加载资源时，根据请求头的`expires`和`cache-control`判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
- 2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过`last-modified`和`etag`验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
- 3）如果前面两者都没有命中，直接从服务器加载资源

#### 强缓存

1. 如果缓存未失效，则直接使用缓存数据，
2. 如果缓存失效，则向服务器请求数据，并将数据和缓存规则写入缓存系统

#### 对比缓存

直接从缓存系统获取数据的标识，请求服务器验证缓存标识对应数据是否失效，如果没有失效，直接从缓存系统获取缓存数据；否则从服务器获取数据并把数据和缓存规则存入缓存系统。



### `HTTP2.0`

1. **二进制格式**。采用二进制格式传输，避免文本传输时因格式解析导致出错。
2. **多路复用**。即连接共享，通过每个`request`对应一个`id`，达到一个连接上有多个`request`，即使每个`request`混杂在一起，也能通过`id`将其分到对应的请求上。
3. **头部压缩**。通过维护一个字典，差量更新`HTTP`头部，大大减低头部消耗的流量。
4. **服务器推送**。将客户端所需文件伴随这`index.html`文件一起传输过来，不用分多次传输，省去了多次传输的申请步骤。



### 同源策略

#### 同源条件

- 协议相同
- 域名相同
- 端口相同

#### 受限制行为

- `cookies`，`localStorage`，`indexDB`无法获取
- `DOM`无法获得
- `ajax`请求无法发送

#### 跨域操作

1. `jsonp`。利用`script`标签没有跨域限制的漏洞，网页可以得到其他来源动态产生的`JSON`数据，但只能使用`get`方法，通过回调函数进行调用数据

   1. `JS`代码

      ```javascript
      function jsonp({ url, params, callback }) {
        return new Promise((resolve, reject) => {
          let script = document.createElement('script')
          window[callback] = function(data) {
            resolve(data)
            document.body.removeChild(script)
          }
          params = { ...params, callback } // wd=b&callback=show
          let arrs = []
          for (let key in params) {
            arrs.push(`${key}=${params[key]}`)
          }
          script.src = `${url}?${arrs.join('&')}`
          document.body.appendChild(script)
        })
      }
      ```

   2. `JQ`代码

      ```javascript
      function ajax(url){
      	$.ajax({
      		url:url,
      		dataType:"jsonp",
      		type:"get",
      		success:function(data){
      			console.log(data)
      		}
      	})
      }
      ```

2. `CORS`

   服务端设置 Access-Control-Allow-Origin 就可以开启 `CORS`。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。支持所有的请求，是解决跨域问题的根本方法

3. `postMessage`

   `postMessage()`方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。

4. `webSocket`

   `WebSocket` 是一种双向通信协议，在建立连接之后，`WebSocket `的 server 与 client 都能主动向对方发送或接收数据。

5. 中间件代理

   **同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。**

   步骤：

   1. 接受客户端请求 。
   2. 将请求转发给服务器
   3. 拿到服务器响应数据。
   4. 将响应转发给客户端。

6. `nginx`反向代理

   通过`nginx`配置一个代理服务器（域名与`domain1`相同，端口不同）做跳板机，反向代理访问`domain2`接口，并且可以顺便修改cookie中`domain`信息，方便当前域cookie写入，实现跨域登录。

7. 通过`iframe`进行跨域

   1. 通过`window.name`进行传值
   2. 通过`location.hash`进行传值
   3. 通过降域进行跨域



### 安全问题

#### `XSS`

跨站脚本攻击。恶意web用户将代码植入到提供给其它用户使用的页面中，攻击者通过注入非法的`html`标签或者`javascript`代码，从而当用户浏览该网页时，控制用户浏览器。

**解决方法**

1. 过滤

   对用户输入进行过滤，对特殊字符进行转义，移出用户输入的`style`节点，`script`节点，`iframe`节点。

2. 编码

   根据输出数据的上下文进行相应的编码

#### `CSRF`

跨站请求伪造。攻击者冒充用户发起请求。通常通过其他网站获取目标网站的`cookie`进行访问。

**解决方法**

1. 使用`token`

   服务器产生一个`token`存到`session`中，并同时发送到客户端，客户端提交数据时需要带上`token`，通过验证`token`来判断是否伪造

2. `Refer`验证

   只接受本站的请求

3. 使用验证码

   要求用户进行交互，避免用户不知情时发送请求



### `cookie`、`session`

#### `cookie`

`cookie`是服务器发送到用户浏览器并保存在本地的一小块数据，他会在浏览器下一次发起请求时与数据一起发送发送到服务器上。

大小为`4k`

##### 用途

1. 会话状态管理（登录状态，购物车，游戏分数等）
2. 个性化设置（用户自定义主题等）
3. 浏览器行为跟踪（跟踪分析用户行为）

##### 创建

服务器收到`http`请求后，在响应报文头部加入`set-cookie`选项，浏览器收到后会保存`cookie`。之后的每一次对服务器的请求都会通过`cookie`请求头部并将`cookie`信息发送到服务器。

##### 时效性

`cookie`在不通过`expires`、`Max-Age`字段设置时效性时，仅是一个会话期`cookie`，在会话结束后便销毁。

`cookie`过期时间设置后，仅与浏览器本地时间相关。

##### 作用域

`Domain`标识指定了哪些主机能接受`cookie`，默认为当前文档主机

`Path`标识指定了主机下哪些路径能接受`cookie`

##### 安全性

标记为`secure`的`cookie`只能通过被`https`加密过的请求发送到服务器。

通过`JS`的`Document.cookie` 可以设置`httpOnly`标记的`cookie`，能够避免`xss`跨域脚本攻击



#### `session`

`Session`是一种记录客户状态的机制，不同于`Cookie`的是`Cookie`保存在客户端浏览器中，而Session保存在服务器上。避免了在客户端`Cookie`中存储敏感数据。

##### 生命周期

`session`保存在服务器的内存中，每一个用户都会有一个独立的`session`，它在用户第一次访问服务器时自动创建，（只有访问`JSP`、`Servlet`等程序时才创建，静态资源不创建）。

`session`创建后，只要用户访问了服务器，服务器就会更新`session`的最后访问时间，不管是否有对`session`进行读写

##### 有效期

为了避免内存溢出，`sesion`在一段时间后从内存删除，这个时间基于最后的访问时间。

##### 浏览器关闭后`session`失效？

`session`访问步骤

1. 用户访问服务器，服务器生成`session`并将`session id`通过会话`cookie`传输到浏览器（会话`cookie`就是没有设置时效性的`cookie`，保存在内存中，在会话结束后就会销毁）
2. 以后的每次非静态资源请求，都会带上这个`cookie`
3. 服务器获取到`cookie`中的`session id`，就会通过`session id`找到`session`信息
4. 会话断开后，会话`cookie`被销毁，`session id `也不存在了，但是服务器中无法得知这个消息，所以服务器中的`session`只能在一段时间后失效
5. 再次访问时，因为`session id`已经销毁，所以传输的请求中`session id`为`null`，服务器会当作一个新的用户进行创建`session`和`session id`

所以浏览器关闭后`session`并未失效，只是找不到了，要等一段时间后自动销毁。

#### `session`与`cookie`区别

1. `session`存储在服务端，`cookie`存储在客户端
2. `session`比`cookie`更安全，因为存储在服务端
3. `session`是服务端保存的一种数据结构，用来跟踪用户的状态，这个数据能保存在集群，数据库文件中
4. `cookie`是客户端保存用户信息的一种机制，用用来记录用户的信息，也是实现`session`的一种方式



### `sessionStorage`、`loaclStorage`

- `sessionStorage` 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。存储在 `sessionStorage` 里面的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话

- `localStorage` 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。只读的`localStorage` 属性允许你访问一个`Document` 源（`origin`）的对象 `Storage`；存储的数据将保存在浏览器会话中。存储在 `localStorage` 的数据可以长期保留。





